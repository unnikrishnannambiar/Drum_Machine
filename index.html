<!DOCTYPE html>
<html>
<head>
    <title>Neumorphic Drum Machine</title>
    <style>
        /* Neumorphic Styles */
        body {
            font-family: Helvetica, Arial, sans-serif;
            background-color: #f0f0f3; /* Off-white background */
            color: #333;
            margin: 0;
            padding: 0;
        }
        h1 {
            text-align: center;
            padding: 20px 0;
        }
        .controls, .metronome-controls {
            text-align: center;
            margin-bottom: 20px;
        }
        .controls input, .metronome-controls select {
            margin: 0 10px;
            width: 60px;
            text-align: center;
        }
        .controls button, .metronome-controls button {
            margin: 0 5px;
            padding: 10px 20px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 14px;
            border: none;
            border-radius: 20px;
            background: #f0f0f3;
            box-shadow:  5px 5px 10px #bebebe,
                         -5px -5px 10px #ffffff;
            color: #333;
            cursor: pointer;
        }
        .controls button:active, .metronome-controls button:active {
            box-shadow: inset 5px 5px 10px #bebebe,
                        inset -5px -5px 10px #ffffff;
        }
        .main-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            max-width: 1200px;
            margin: 0 auto;
        }
        .visualization-container {
            display: flex;
            margin: 20px;
        }
        #snake-container {
            position: relative;
            width: 300px;
            height: 300px;
            background-color: #f0f0f3;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: inset 10px 10px 20px #bebebe,
                        inset -10px -10px 20px #ffffff;
        }
        #global-sequencer {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            grid-gap: 5px;
            margin-left: 20px;
            width: 300px;
            height: 300px;
        }
        .global-step {
            width: 100%;
            height: 100%;
            background: #f0f0f3;
            border-radius: 10px;
            box-shadow: 5px 5px 10px #bebebe,
                        -5px -5px 10px #ffffff;
            transition: background-color 0.1s ease, box-shadow 0.1s ease;
            cursor: pointer;
        }
        .global-step.active {
            background: #e0e0e3; /* Slightly darker off-white */
            box-shadow: inset 5px 5px 10px #bebebe,
                        inset -5px -5px 10px #ffffff;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 20px;
            max-width: 800px;
            margin: 0 auto;
            padding-bottom: 50px;
        }
        .pad-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .pad {
            width: 100%;
            padding-top: 100%; /* Makes the pad a square */
            position: relative;
            text-align: center;
            cursor: pointer;
            border-radius: 20px;
            user-select: none;
            background: #f0f0f3;
            box-shadow:  10px 10px 20px #bebebe,
                         -10px -10px 20px #ffffff;
            transition: background-color 0.1s ease, box-shadow 0.1s ease;
        }
        .pad-label {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
        }
        .pad:hover {
            box-shadow: inset 10px 10px 20px #bebebe,
                        inset -10px -10px 20px #ffffff;
        }
        .load-button {
            margin-top: 10px;
            padding: 5px 10px;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 12px;
            border: none;
            border-radius: 10px;
            background: #f0f0f3;
            box-shadow:  3px 3px 6px #bebebe,
                         -3px -3px 6px #ffffff;
            color: #333;
            cursor: pointer;
        }
        .load-button:active {
            box-shadow: inset 3px 3px 6px #bebebe,
                        inset -3px -3px 6px #ffffff;
        }
        .knob-container {
            margin-top: 10px;
            width: 80px;
            height: 80px;
            position: relative;
        }
        .knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: #f0f0f3;
            box-shadow: inset 5px 5px 10px #bebebe,
                        inset -5px -5px 10px #ffffff;
            position: relative;
            cursor: pointer;
        }
        .knob-marker {
            width: 4px;
            height: 20px;
            background: #333;
            position: absolute;
            top: 10%;
            left: 50%;
            transform-origin: bottom center;
            transform: rotate(0deg) translateX(-50%);
            transition: transform 0.1s ease;
        }
        /* Styles for the snake animation */
        .snake-segment {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #e0e0e3; /* Slightly darker off-white */
            border-radius: 5px;
            box-shadow: 2px 2px 5px #bebebe,
                        -2px -2px 5px #ffffff;
        }
    </style>
</head>
<body>
    <h1>Neumorphic Drum Machine</h1>
    <div class="controls">
        <label for="bpm">BPM:</label>
        <input type="number" id="bpm" value="120" min="60" max="240">
        <button id="play">Play</button>
        <button id="stop">Stop</button>
    </div>
    <div class="metronome-controls">
        <label>
            <input type="checkbox" id="metronome-toggle" checked>
            Metronome
        </label>
        <label for="metronome-subdivision">Subdivision:</label>
        <select id="metronome-subdivision">
            <option value="1">1 Beat</option>
            <option value="2">Half Beat</option>
            <option value="4">Quarter Beat</option>
            <option value="8">Eighth Beat</option>
            <option value="16">Sixteenth Beat</option>
        </select>
        <button id="load-metronome-sound">Load Metronome Sound</button>
        <input type="file" id="metronome-file" accept="audio/*" style="display:none;">
    </div>
    <div class="main-container">
        <div class="visualization-container">
            <div id="snake-container">
                <!-- Snake segments will be generated here -->
            </div>
            <div id="global-sequencer">
                <!-- Global sequencer steps -->
            </div>
        </div>
    </div>
    <div class="grid">
        <!-- Pads will be generated here -->
    </div>

    <script>
        const grid = document.querySelector('.grid');
        const bpmInput = document.getElementById('bpm');
        const playButton = document.getElementById('play');
        const stopButton = document.getElementById('stop');
        const snakeContainer = document.getElementById('snake-container');
        const globalSequencer = document.getElementById('global-sequencer');

        // Metronome elements
        const metronomeToggle = document.getElementById('metronome-toggle');
        const metronomeSubdivision = document.getElementById('metronome-subdivision');
        const loadMetronomeSoundButton = document.getElementById('load-metronome-sound');
        const metronomeFileInput = document.getElementById('metronome-file');

        const samples = [];
        const sampleDurations = []; // Store sample playback durations
        const sequences = new Array(16).fill(false); // Global sequencer with 16 steps
        let currentStep = 0;
        let intervalId = null;

        // Metronome variables
        let metronomeSample = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YRAAAAAA'); // Default click sound
        let metronomeSteps = [];

        // Snake variables
        let snake = [{ x: 150, y: 150 }];
        const snakeSize = 15;
        const snakeMaxLength = 16; // Max length equal to the number of steps
        const containerWidth = 300;
        const containerHeight = 300;

        // Pad colors based on provided hex codes
        const padColors = ['#b3c2f2', '#735cdd', '#9000b3', '#7e007b', '#37000a'];

        // Default ASCII sounds (simple generated tones)
        const defaultSounds = [];

        // Generate default sounds (simple beep sounds)
        for (let i = 0; i < 16; i++) {
            const frequency = 220 + i * 20; // Different frequency for each pad
            const duration = 0.2; // 200 milliseconds
            const sampleRate = 44100;
            const numSamples = sampleRate * duration;
            const audioBuffer = new Float32Array(numSamples);

            for (let j = 0; j < numSamples; j++) {
                audioBuffer[j] = Math.sin(2 * Math.PI * frequency * (j / sampleRate));
            }

            // Create a Blob from the audio buffer
            const wavData = encodeWAV(audioBuffer, 1, sampleRate);
            const blob = new Blob([wavData], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            defaultSounds.push(url);
        }

        // Function to encode audio buffer to WAV format
        function encodeWAV(samples, numChannels, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            /* RIFF identifier */
            writeString(view, 0, 'RIFF');
            /* file length */
            view.setUint32(4, 36 + samples.length * 2, true);
            /* RIFF type */
            writeString(view, 8, 'WAVE');
            /* format chunk identifier */
            writeString(view, 12, 'fmt ');
            /* format chunk length */
            view.setUint32(16, 16, true);
            /* sample format (raw) */
            view.setUint16(20, 1, true);
            /* channel count */
            view.setUint16(22, numChannels, true);
            /* sample rate */
            view.setUint32(24, sampleRate, true);
            /* byte rate (sample rate * block align) */
            view.setUint32(28, sampleRate * numChannels * 2, true);
            /* block align (channel count * bytes per sample) */
            view.setUint16(32, numChannels * 2, true);
            /* bits per sample */
            view.setUint16(34, 16, true);
            /* data chunk identifier */
            writeString(view, 36, 'data');
            /* data chunk length */
            view.setUint32(40, samples.length * 2, true);

            // Write the PCM samples
            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }

            return view;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Initialize global sequencer
        for (let step = 0; step < 16; step++) {
            const stepDiv = document.createElement('div');
            stepDiv.classList.add('global-step');
            stepDiv.dataset.step = step;

            // Make steps clickable
            stepDiv.addEventListener('click', () => {
                const stepIndex = parseInt(stepDiv.dataset.step, 10);
                sequences[stepIndex] = !sequences[stepIndex];
                stepDiv.classList.toggle('active');
            });

            globalSequencer.appendChild(stepDiv);
        }

        // Initialize pads
        for(let i = 0; i < 16; i++) {
            const padContainer = document.createElement('div');
            padContainer.classList.add('pad-container');

            const pad = document.createElement('div');
            pad.classList.add('pad');
            pad.dataset.pad = i;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'audio/*';
            input.style.display = 'none';

            const label = document.createElement('span');
            label.classList.add('pad-label');
            label.textContent = `Pad ${i+1}`;

            pad.appendChild(input);
            pad.appendChild(label);

            pad.addEventListener('click', () => {
                const padIndex = parseInt(pad.dataset.pad, 10);
                if (samples[padIndex]) {
                    // Play the sample
                    samples[padIndex].currentTime = 0; // Reset playback to start
                    samples[padIndex].play();
                } else {
                    // No sample loaded, trigger the file input
                    input.click();
                }
            });

            input.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const padIndex = parseInt(pad.dataset.pad, 10);
                    const audioURL = URL.createObjectURL(file);
                    const audio = new Audio(audioURL);
                    audio.load(); // Load the audio
                    samples[padIndex] = audio;
                    // Update the label to show the sample name
                    label.textContent = file.name;
                }
            });

            padContainer.appendChild(pad);

            // Load Sample button
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load Sample';
            loadButton.classList.add('load-button');
            loadButton.addEventListener('click', () => {
                input.click();
            });
            padContainer.appendChild(loadButton);

            // Knob fader for controlling playback duration
            const knobContainer = document.createElement('div');
            knobContainer.classList.add('knob-container');

            const knob = document.createElement('div');
            knob.classList.add('knob');
            knob.dataset.pad = i;

            const knobMarker = document.createElement('div');
            knobMarker.classList.add('knob-marker');
            knob.appendChild(knobMarker);

            // Store the duration for each sample
            sampleDurations[i] = 5; // Default to full length

            let isDragging = false;
            let startY = 0;
            let startAngle = 0;

            knob.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startAngle = parseFloat(knob.dataset.angle) || 0;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dy = startY - e.clientY;
                    let angle = startAngle + dy;
                    angle = Math.max(-135, Math.min(135, angle));
                    knob.dataset.angle = angle;
                    knobMarker.style.transform = `rotate(${angle}deg) translateX(-50%)`;
                    const padIndex = parseInt(knob.dataset.pad, 10);
                    const value = ((angle + 135) / 270) * 5 + 0.1; // Range from 0.1 to 5 seconds
                    sampleDurations[padIndex] = value.toFixed(2);
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            knobContainer.appendChild(knob);
            padContainer.appendChild(knobContainer);

            grid.appendChild(padContainer);

            // Load default sound
            const defaultSoundUrl = defaultSounds[i % defaultSounds.length];
            const audio = new Audio(defaultSoundUrl);
            audio.load();
            samples[i] = audio;
            // Update the label to show the sample name
            label.textContent = `Default Sound ${i+1}`;
        }

        function initializeMetronome() {
            const subdivision = parseInt(metronomeSubdivision.value, 10);
            metronomeSteps = [];
            for (let i = 0; i < 16; i++) {
                if ((i * subdivision) % 16 === 0) {
                    metronomeSteps.push(true);
                } else {
                    metronomeSteps.push(false);
                }
            }
        }

        function playLoop() {
            const bpm = parseInt(bpmInput.value, 10);
            const interval = (60 / bpm) * 1000 / 4; // 16 steps per measure
            if (intervalId) clearInterval(intervalId);
            initializeMetronome();
            intervalId = setInterval(() => {
                // Reset all pads to default color
                for (let i = 0; i < 16; i++) {
                    const pad = document.querySelector(`.pad[data-pad="${i}"]`);
                    pad.style.background = '#f0f0f3'; // default off-white color
                    pad.style.boxShadow = '10px 10px 20px #bebebe, -10px -10px 20px #ffffff'; // default box-shadow
                }

                // Reset global sequencer steps
                const globalSteps = document.querySelectorAll('.global-step');
                globalSteps.forEach(step => step.classList.remove('active'));

                // Highlight current global step
                const currentGlobalStep = document.querySelector(`.global-step[data-step="${currentStep}"]`);
                currentGlobalStep.classList.add('active');

                // Play metronome
                if (metronomeToggle.checked && metronomeSteps[currentStep]) {
                    metronomeSample.currentTime = 0;
                    metronomeSample.play();
                }

                // Play samples and light up pads
                if (sequences[currentStep]) {
                    for (let i = 0; i < 16; i++) {
                        if (samples[i]) {
                            samples[i].currentTime = 0;
                            samples[i].play();

                            // Stop the sample after specified duration
                            const duration = sampleDurations[i];
                            setTimeout(() => {
                                samples[i].pause();
                                samples[i].currentTime = 0;
                            }, duration * 1000);

                            // Light up the pad
                            const pad = document.querySelector(`.pad[data-pad="${i}"]`);
                            const padColor = padColors[i % padColors.length];
                            pad.style.background = padColor;
                            pad.style.boxShadow = 'inset 10px 10px 20px #bebebe, inset -10px -10px 20px #ffffff';
                        }
                    }
                }

                // Move snake
                moveSnake();
                currentStep = (currentStep + 1) % 16;
            }, interval);
        }

        playButton.addEventListener('click', () => {
            currentStep = 0;
            resetSnake();
            playLoop();
        });

        stopButton.addEventListener('click', () => {
            if (intervalId) clearInterval(intervalId);
        });

        bpmInput.addEventListener('change', () => {
            if (intervalId) {
                playLoop();
            }
        });

        metronomeSubdivision.addEventListener('change', () => {
            if (intervalId) {
                playLoop();
            }
        });

        // Load custom metronome sound
        loadMetronomeSoundButton.addEventListener('click', () => {
            metronomeFileInput.click();
        });

        metronomeFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const audioURL = URL.createObjectURL(file);
                const audio = new Audio(audioURL);
                audio.load();
                metronomeSample = audio;
            }
        });

        // Snake functions
        function resetSnake() {
            snake = [{ x: 150, y: 150 }];
            renderSnake();
        }

        function moveSnake() {
            const newHead = { ...snake[snake.length - 1] };

            // Random movement
            const directions = [
                { x: 0, y: -snakeSize }, // Up
                { x: snakeSize, y: 0 },  // Right
                { x: 0, y: snakeSize },  // Down
                { x: -snakeSize, y: 0 }  // Left
            ];

            // Choose a random direction
            const randomDirection = directions[Math.floor(Math.random() * directions.length)];

            newHead.x += randomDirection.x;
            newHead.y += randomDirection.y;

            // Keep the snake within bounds
            newHead.x = Math.max(0, Math.min(newHead.x, containerWidth - snakeSize));
            newHead.y = Math.max(0, Math.min(newHead.y, containerHeight - snakeSize));

            snake.push(newHead);

            if (snake.length > snakeMaxLength) {
                snake.shift(); // Remove the tail segment
            }

            renderSnake();
        }

        function renderSnake() {
            // Clear previous snake
            snakeContainer.innerHTML = '';

            snake.forEach(segment => {
                const segmentDiv = document.createElement('div');
                segmentDiv.classList.add('snake-segment');
                segmentDiv.style.left = segment.x + 'px';
                segmentDiv.style.top = segment.y + 'px';
                snakeContainer.appendChild(segmentDiv);
            });
        }
    </script>
</body>
</html>
